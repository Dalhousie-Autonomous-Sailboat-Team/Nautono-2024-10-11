<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>New_RTOS_Sailboat: SAM RTC Count (RTC COUNT) Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">New_RTOS_Sailboat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">SAM RTC Count (RTC COUNT) Driver</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtc__count__events.html">rtc_count_events</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTC Count event enable/disable structure.  <a href="structrtc__count__events.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtc__module.html">rtc_module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device structure.  <a href="structrtc__module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtc__count__config.html">rtc_count_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTC Count configuration structure.  <a href="structrtc__count__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Driver Feature Definition</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >Define port features set according to different device family. </p>
</td></tr>
<tr class="memitem:ga1c6c05a342b2711713cfac6fb3d6256c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga1c6c05a342b2711713cfac6fb3d6256c">rtc_count_mode</a> { <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gga1c6c05a342b2711713cfac6fb3d6256cac1469285bb822ce84f262cd4117e8edc">RTC_COUNT_MODE_16BIT</a> = 0
, <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gga1c6c05a342b2711713cfac6fb3d6256cad94f227d25afd2fa3c26ef9a5a33e4d8">RTC_COUNT_MODE_32BIT</a> = 1
 }</td></tr>
<tr class="memdesc:ga1c6c05a342b2711713cfac6fb3d6256c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available operation modes for the RTC.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga1c6c05a342b2711713cfac6fb3d6256c">More...</a><br /></td></tr>
<tr class="separator:ga1c6c05a342b2711713cfac6fb3d6256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfcb8b12ca245948cbedc1ad81c3e589"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> { <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggadfcb8b12ca245948cbedc1ad81c3e589ac7340ee61643d3bdb0a7b4264335f080">RTC_COUNT_COMPARE_0</a> = 0
 }</td></tr>
<tr class="memdesc:gadfcb8b12ca245948cbedc1ad81c3e589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available compare channels.  <a href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">More...</a><br /></td></tr>
<tr class="separator:gadfcb8b12ca245948cbedc1ad81c3e589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce60ab36a74de9a173788f4aa896d15"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gacce60ab36a74de9a173788f4aa896d15">rtc_count_prescaler</a> { <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15aa5a98b865348eb598140b2a4247916e9">RTC_COUNT_PRESCALER_DIV_1</a> = RTC_MODE0_CTRL_PRESCALER_DIV1
, <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a312d3c72451ac000e95d335183ad7ec3">RTC_COUNT_PRESCALER_DIV_2</a> = RTC_MODE0_CTRL_PRESCALER_DIV2
, <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15ac82d71266c2f83c3d51b51fedd1ae920">RTC_COUNT_PRESCALER_DIV_4</a> = RTC_MODE0_CTRL_PRESCALER_DIV4
, <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15ac0061a5a79673614095663596f9e79f4">RTC_COUNT_PRESCALER_DIV_8</a> = RTC_MODE0_CTRL_PRESCALER_DIV8
, <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a4e17e7e9d43d022235a7550dccffcddd">RTC_COUNT_PRESCALER_DIV_16</a> = RTC_MODE0_CTRL_PRESCALER_DIV16
, <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a3b83f1963700137784f61cd05ef49b7e">RTC_COUNT_PRESCALER_DIV_32</a> = RTC_MODE0_CTRL_PRESCALER_DIV32
, <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a8b59673e870fd1205aa08b667fcc58b6">RTC_COUNT_PRESCALER_DIV_64</a> = RTC_MODE0_CTRL_PRESCALER_DIV64
, <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a2d736f3fdd6be715588ee09d7a8d1deb">RTC_COUNT_PRESCALER_DIV_128</a> = RTC_MODE0_CTRL_PRESCALER_DIV128
, <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a4d6f94d95f1e40f463a83148a57edcfa">RTC_COUNT_PRESCALER_DIV_256</a> = RTC_MODE0_CTRL_PRESCALER_DIV256
, <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15ab58a33623afbb13b74dcbd7e50e7760b">RTC_COUNT_PRESCALER_DIV_512</a> = RTC_MODE0_CTRL_PRESCALER_DIV512
, <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ggacce60ab36a74de9a173788f4aa896d15a9766bc273a9d05a8345615c5707eb4a7">RTC_COUNT_PRESCALER_DIV_1024</a> = RTC_MODE0_CTRL_PRESCALER_DIV1024
<br />
 }</td></tr>
<tr class="memdesc:gacce60ab36a74de9a173788f4aa896d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTC input clock prescaler settings.  <a href="group__asfdoc__sam0__rtc__count__group.html#gacce60ab36a74de9a173788f4aa896d15">More...</a><br /></td></tr>
<tr class="separator:gacce60ab36a74de9a173788f4aa896d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728e9addb0162893a3a2c9100ebd7920"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga728e9addb0162893a3a2c9100ebd7920">FEATURE_RTC_CONTINUOUSLY_UPDATED</a></td></tr>
<tr class="separator:ga728e9addb0162893a3a2c9100ebd7920"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Configuration and Initialization</h2></td></tr>
<tr class="memitem:ga161d6cf1f6f717e8c6c650dc587cdf7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga161d6cf1f6f717e8c6c650dc587cdf7a">rtc_count_reset</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module)</td></tr>
<tr class="memdesc:ga161d6cf1f6f717e8c6c650dc587cdf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the RTC module. Resets the RTC to hardware defaults.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga161d6cf1f6f717e8c6c650dc587cdf7a">More...</a><br /></td></tr>
<tr class="separator:ga161d6cf1f6f717e8c6c650dc587cdf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49e022ac982b14f592b4741fe076add"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gad49e022ac982b14f592b4741fe076add">rtc_count_enable</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module)</td></tr>
<tr class="memdesc:gad49e022ac982b14f592b4741fe076add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the RTC module.  <a href="group__asfdoc__sam0__rtc__count__group.html#gad49e022ac982b14f592b4741fe076add">More...</a><br /></td></tr>
<tr class="separator:gad49e022ac982b14f592b4741fe076add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f97a58f45fe3fdeec606c155d4d8f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga40f97a58f45fe3fdeec606c155d4d8f3">rtc_count_disable</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module)</td></tr>
<tr class="memdesc:ga40f97a58f45fe3fdeec606c155d4d8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the RTC module.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga40f97a58f45fe3fdeec606c155d4d8f3">More...</a><br /></td></tr>
<tr class="separator:ga40f97a58f45fe3fdeec606c155d4d8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff43df79be7aeea0d559eafbe5fdbdc3"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gaff43df79be7aeea0d559eafbe5fdbdc3">rtc_count_init</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, <a class="el" href="union_rtc.html">Rtc</a> *const hw, const struct <a class="el" href="structrtc__count__config.html">rtc_count_config</a> *const config)</td></tr>
<tr class="memdesc:gaff43df79be7aeea0d559eafbe5fdbdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the RTC module with given configurations.  <a href="group__asfdoc__sam0__rtc__count__group.html#gaff43df79be7aeea0d559eafbe5fdbdc3">More...</a><br /></td></tr>
<tr class="separator:gaff43df79be7aeea0d559eafbe5fdbdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadccb737db7dd01d7190a7f9e18b23a1b"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadccb737db7dd01d7190a7f9e18b23a1b">rtc_count_frequency_correction</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const int8_t value)</td></tr>
<tr class="memdesc:gadccb737db7dd01d7190a7f9e18b23a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate for too-slow or too-fast oscillator.  <a href="group__asfdoc__sam0__rtc__count__group.html#gadccb737db7dd01d7190a7f9e18b23a1b">More...</a><br /></td></tr>
<tr class="separator:gadccb737db7dd01d7190a7f9e18b23a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Count and Compare Value Management</h2></td></tr>
<tr class="memitem:ga3770c2c6f82daca6ca28670cd87be46f"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga3770c2c6f82daca6ca28670cd87be46f">rtc_count_set_count</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const uint32_t count_value)</td></tr>
<tr class="memdesc:ga3770c2c6f82daca6ca28670cd87be46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current count value to desired value.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga3770c2c6f82daca6ca28670cd87be46f">More...</a><br /></td></tr>
<tr class="separator:ga3770c2c6f82daca6ca28670cd87be46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad10283f223feb3c958ccabe9d0662a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga3ad10283f223feb3c958ccabe9d0662a">rtc_count_get_count</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module)</td></tr>
<tr class="memdesc:ga3ad10283f223feb3c958ccabe9d0662a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current count value.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga3ad10283f223feb3c958ccabe9d0662a">More...</a><br /></td></tr>
<tr class="separator:ga3ad10283f223feb3c958ccabe9d0662a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c76be0e0fdfb5b1f9a883f396756f4"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga56c76be0e0fdfb5b1f9a883f396756f4">rtc_count_set_compare</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const uint32_t comp_value, const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> comp_index)</td></tr>
<tr class="memdesc:ga56c76be0e0fdfb5b1f9a883f396756f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the compare value for the specified compare.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga56c76be0e0fdfb5b1f9a883f396756f4">More...</a><br /></td></tr>
<tr class="separator:ga56c76be0e0fdfb5b1f9a883f396756f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40e535c1375a99492e114722af93b675"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga40e535c1375a99492e114722af93b675">rtc_count_get_compare</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, uint32_t *const comp_value, const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> comp_index)</td></tr>
<tr class="memdesc:ga40e535c1375a99492e114722af93b675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current compare value of specified compare.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga40e535c1375a99492e114722af93b675">More...</a><br /></td></tr>
<tr class="separator:ga40e535c1375a99492e114722af93b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b0d3a10ee5368b5484f99e6b6fecb8"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gac0b0d3a10ee5368b5484f99e6b6fecb8">rtc_count_set_period</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, uint16_t period_value)</td></tr>
<tr class="memdesc:gac0b0d3a10ee5368b5484f99e6b6fecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given value to the period.  <a href="group__asfdoc__sam0__rtc__count__group.html#gac0b0d3a10ee5368b5484f99e6b6fecb8">More...</a><br /></td></tr>
<tr class="separator:gac0b0d3a10ee5368b5484f99e6b6fecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747385c5686f746a64f118705c22c894"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga747385c5686f746a64f118705c22c894">rtc_count_get_period</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, uint16_t *const period_value)</td></tr>
<tr class="memdesc:ga747385c5686f746a64f118705c22c894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value of period.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga747385c5686f746a64f118705c22c894">More...</a><br /></td></tr>
<tr class="separator:ga747385c5686f746a64f118705c22c894"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Status Management</h2></td></tr>
<tr class="memitem:ga354d81abc8c33bc39a238418611b3239"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga354d81abc8c33bc39a238418611b3239">rtc_count_is_compare_match</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> comp_index)</td></tr>
<tr class="memdesc:ga354d81abc8c33bc39a238418611b3239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if RTC compare match has occurred.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga354d81abc8c33bc39a238418611b3239">More...</a><br /></td></tr>
<tr class="separator:ga354d81abc8c33bc39a238418611b3239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51cd67b23c2a4716d09b08bf2422a222"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga51cd67b23c2a4716d09b08bf2422a222">rtc_count_clear_compare_match</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a> comp_index)</td></tr>
<tr class="memdesc:ga51cd67b23c2a4716d09b08bf2422a222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears RTC compare match flag.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga51cd67b23c2a4716d09b08bf2422a222">More...</a><br /></td></tr>
<tr class="separator:ga51cd67b23c2a4716d09b08bf2422a222"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Callbacks</h2></td></tr>
<tr class="memitem:ga3679d842a95a0086fa5cbccf74aad7ee"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga3679d842a95a0086fa5cbccf74aad7ee">rtc_count_register_callback</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, rtc_count_callback_t callback, enum rtc_count_callback callback_type)</td></tr>
<tr class="memdesc:ga3679d842a95a0086fa5cbccf74aad7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers callback for the specified callback type.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga3679d842a95a0086fa5cbccf74aad7ee">More...</a><br /></td></tr>
<tr class="separator:ga3679d842a95a0086fa5cbccf74aad7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a8ffb958261a9b9a955c0f8fb942ea"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gac5a8ffb958261a9b9a955c0f8fb942ea">rtc_count_unregister_callback</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, enum rtc_count_callback callback_type)</td></tr>
<tr class="memdesc:gac5a8ffb958261a9b9a955c0f8fb942ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters callback for the specified callback type.  <a href="group__asfdoc__sam0__rtc__count__group.html#gac5a8ffb958261a9b9a955c0f8fb942ea">More...</a><br /></td></tr>
<tr class="separator:gac5a8ffb958261a9b9a955c0f8fb942ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7636683b59afd3c0d07b1191a5aff86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gaf7636683b59afd3c0d07b1191a5aff86">rtc_count_enable_callback</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, enum rtc_count_callback callback_type)</td></tr>
<tr class="memdesc:gaf7636683b59afd3c0d07b1191a5aff86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables callback.  <a href="group__asfdoc__sam0__rtc__count__group.html#gaf7636683b59afd3c0d07b1191a5aff86">More...</a><br /></td></tr>
<tr class="separator:gaf7636683b59afd3c0d07b1191a5aff86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bee70da6626ecddb461498be2c6a1b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga9bee70da6626ecddb461498be2c6a1b5">rtc_count_disable_callback</a> (struct <a class="el" href="structrtc__module.html">rtc_module</a> *const module, enum rtc_count_callback callback_type)</td></tr>
<tr class="memdesc:ga9bee70da6626ecddb461498be2c6a1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables callback.  <a href="group__asfdoc__sam0__rtc__count__group.html#ga9bee70da6626ecddb461498be2c6a1b5">More...</a><br /></td></tr>
<tr class="separator:ga9bee70da6626ecddb461498be2c6a1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >This driver for Atmel&reg; | SMART ARM&reg;-based microcontrollers provides an interface for the configuration and management of the device's Real Time Clock functionality in Count operating mode, for the configuration and retrieval of the current RTC counter value. The following driver API modes are covered by this manual:</p>
<ul>
<li>Polled APIs </li>
</ul>
<p >The following peripheral is used by this module:</p><ul>
<li>RTC (Real Time Clock)</li>
</ul>
<p >The following devices can use this module:</p><ul>
<li>Atmel | SMART SAM D20/D21</li>
<li>Atmel | SMART SAM R21</li>
<li>Atmel | SMART SAM D09/D10/D11</li>
<li>Atmel | SMART SAM L21/L22</li>
<li>Atmel | SMART SAM DA1</li>
<li>Atmel | SMART SAM C20/C21</li>
<li>Atmel | SMART SAM HA1</li>
<li>Atmel | SMART SAM R30</li>
<li>Atmel | SMART SAM R34</li>
<li>Atmel | SMART SAM R35</li>
</ul>
<p >The outline of this documentation is as follows:</p><ul>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_prerequisites">Prerequisites</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_module_overview">Module Overview</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_special_considerations">Special Considerations</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_extra_info">Extra Information</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_examples">Examples</a></li>
<li><a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_api_overview">API Overview</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_rtc_count_prerequisites"></a>
Prerequisites</h1>
<p >There are no prerequisites for this module.</p>
<h1><a class="anchor" id="asfdoc_sam0_rtc_count_module_overview"></a>
Module Overview</h1>
<p >The RTC module in the SAM devices is a 32-bit counter, with a 10-bit programmable prescaler. Typically, the RTC clock is run continuously, including in the device's low-power sleep modes, to track the current time and date information. The RTC can be used as a source to wake up the system at a scheduled time or periodically using the alarm functions.</p>
<p >In this driver, the RTC is operated in Count mode. This allows for an easy integration of an asynchronous counter into a user application, which is capable of operating while the device is in sleep mode.</p>
<p >Whilst operating in Count mode, the RTC features:</p><ul>
<li>16-bit counter mode<ul>
<li>Selectable counter period</li>
<li>Up to six configurable compare values</li>
</ul>
</li>
<li>32-bit counter mode<ul>
<li>Clear counter value on match</li>
<li>Up to four configurable compare values</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_features"></a>
Driver Feature Macro Definition</h2>
<table class="doxtable">
<tr>
<th>Driver Feature Macro </th><th>Supported devices  </th></tr>
<tr>
<td>FEATURE_RTC_PERIODIC_INT </td><td>SAM L21/L22/C20/C21/R30  </td></tr>
<tr>
<td>FEATURE_RTC_PRESCALER_OFF </td><td>SAM L21/L22/C20/C21/R30  </td></tr>
<tr>
<td>FEATURE_RTC_CLOCK_SELECTION </td><td>SAM L21/L22/C20/C21/R30  </td></tr>
<tr>
<td>FEATURE_RTC_GENERAL_PURPOSE_REG </td><td>SAM L21/L22/R30  </td></tr>
<tr>
<td>FEATURE_RTC_CONTINUOUSLY_UPDATED </td><td>SAM D20, SAM D21, SAM R21, SAM D10, SAM D11, SAM DA1, SAM HA1  </td></tr>
<tr>
<td>FEATURE_RTC_TAMPER_DETECTION </td><td>SAM L22  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The specific features are only available in the driver when the selected device supports those features.</dd></dl>
<h1><a class="anchor" id="asfdoc_sam0_rtc_count_module_overview_compares"></a>
Compare and Overflow</h1>
<p >The RTC can be used with up to 4/6 compare values (depending on selected operation mode). These compare values will trigger on match with the current RTC counter value, and can be set up to trigger an interrupt, event, or both. The RTC can also be configured to clear the counter value on compare match in 32-bit mode, resetting the count value back to zero.</p>
<p >If the RTC is operated without the Clear on Match option enabled, or in 16-bit mode, the RTC counter value will instead be cleared on overflow once the maximum count value has been reached:</p>
<p class="formulaDsp">
<picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ COUNT_{MAX} = 2^{32}-1 \]" src="form_2.png"/></picture>
</p>
<p> for 32-bit counter mode, and </p><p class="formulaDsp">
<picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ COUNT_{MAX} = 2^{16}-1 \]" src="form_3.png"/></picture>
</p>
<p> for 16-bit counter mode.</p>
<p >When running in 16-bit mode, the overflow value is selectable with a period value. The counter overflow will then occur when the counter value reaches the specified period value.</p>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_module_overview_periodic"></a>
Periodic Events</h2>
<p >The RTC can generate events at periodic intervals, allowing for direct peripheral actions without CPU intervention. The periodic events can be generated on the upper eight bits of the RTC prescaler, and will be generated on the rising edge transition of the specified bit. The resulting periodic frequency can be calculated by the following formula:</p>
<p class="formulaDsp">
<picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ f_{PERIODIC}=\frac{f_{ASY}}{2^{n+3}} \]" src="form_4.png"/></picture>
</p>
<p >Where <picture><source srcset="form_5_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$f_{ASY}$" src="form_5.png"/></picture> refers to the <em>asynchronous</em> clock is set up in the RTC module configuration. The <b>n</b> parameter is the event source generator index of the RTC module. If the asynchronous clock is operated at the recommended frequency of 1KHz, the formula results in the values shown in <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_module_rtc_hz">the table below</a>.</p>
<p ><a class="anchor" id="asfdoc_sam0_rtc_count_module_rtc_hz"></a></p><table class="doxtable">
<caption>RTC Event Frequencies for Each Prescaler Bit Using a 1KHz Clock</caption>
<tr>
<th>n </th><th>Periodic event  </th></tr>
<tr>
<td>7 </td><td>1Hz  </td></tr>
<tr>
<td>6 </td><td>2Hz  </td></tr>
<tr>
<td>5 </td><td>4Hz  </td></tr>
<tr>
<td>4 </td><td>8Hz  </td></tr>
<tr>
<td>3 </td><td>16Hz  </td></tr>
<tr>
<td>2 </td><td>32Hz  </td></tr>
<tr>
<td>1 </td><td>64Hz  </td></tr>
<tr>
<td>0 </td><td>128Hz  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The connection of events between modules requires the use of the SAM Event System (EVENTS) Driver to route output event of one module to the the input event of another. For more information on event routing, refer to the event driver documentation.</dd></dl>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_module_overview_correction"></a>
Digital Frequency Correction</h2>
<p >The RTC module contains Digital Frequency Correction logic to compensate for inaccurate source clock frequencies which would otherwise result in skewed time measurements. The correction scheme requires that at least two bits in the RTC module prescaler are reserved by the correction logic. As a result of this implementation, frequency correction is only available when the RTC is running from a 1Hz reference clock.</p>
<p >The correction procedure is implemented by subtracting or adding a single cycle from the RTC prescaler every 1024 RTC GCLK cycles. The adjustment is applied the specified number of time (maximum 127) over 976 of these periods. The corresponding correction in PPM will be given by:</p>
<p class="formulaDsp">
<picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\[ Correction(PPM) = \frac{VALUE}{999424}10^6 \]" src="form_6.png"/></picture>
</p>
<p >The RTC clock will tick faster if provided with a positive correction value, and slower when given a negative correction value.</p>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_module_overview_tamper_detect"></a>
RTC Tamper Detect</h2>
<p >see <a class="el" href="C:/Users/mrcoc/repos/dalMAST/Alex_RTOS_Sailboat/RTOS_framework_v1/src/ASF/sam0/drivers/rtc/rtc_tamper.h#asfdoc_sam0_rtc_tamper_detect">RTC Tamper Detect</a></p>
<h1><a class="anchor" id="asfdoc_sam0_rtc_count_special_considerations"></a>
Special Considerations</h1>
<h2><a class="anchor" id="asfdoc_sam0_rtc_count_special_considerations_clock"></a>
Clock Setup</h2>
<h3><a class="anchor" id="asfdoc_sam0_rtc_count_clock_samd_r"></a>
SAM D20/D21/R21/D10/D11/DA1/HA1 Clock Setup</h3>
<p >The RTC is typically clocked by a specialized GCLK generator that has a smaller prescaler than the others. By default the RTC clock is on, selected to use the internal 32KHz RC-oscillator with a prescaler of 32, giving a resulting clock frequency of 1KHz to the RTC. When the internal RTC prescaler is set to 1024, this yields an end-frequency of 1Hz.</p>
<p >The implementer also has the option to set other end-frequencies. <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_rtc_out_freq">The table below</a> lists the available RTC frequencies for each possible GCLK and RTC input prescaler options.</p>
<p ><a class="anchor" id="asfdoc_sam0_rtc_count_rtc_out_freq"></a></p><table class="doxtable">
<caption>RTC Output Frequencies from Allowable Input Clocks</caption>
<tr>
<th>End-frequency </th><th>GCLK prescaler </th><th>RTC prescaler  </th></tr>
<tr>
<td>32KHz </td><td>1 </td><td>1  </td></tr>
<tr>
<td>1KHz </td><td>32 </td><td>1  </td></tr>
<tr>
<td>1Hz </td><td>32 </td><td>1024  </td></tr>
</table>
<p >The overall RTC module clocking scheme is shown in <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_rtc_clock_fig">the figure below</a>.</p>
<p ><a class="anchor" id="asfdoc_sam0_rtc_count_rtc_clock_fig"></a></p>
<h3><a class="anchor" id="asfdoc_sam0_rtc_count_clock_saml"></a>
SAM L21/C20/C21/R30 Clock Setup</h3>
<p >The RTC clock can be selected from OSC32K, XOSC32K, or OSCULP32K, and a 32KHz or 1KHz oscillator clock frequency is required. This clock must be configured and enabled in the 32KHz oscillator controller before using the RTC.</p>
<p >The table below lists the available RTC clock <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#asfdoc_sam0_rtc_count_rtc_clk">asfdoc_sam0_rtc_count_rtc_clk</a>.</p>
<p ><a class="anchor" id="asfdoc_sam0_rtc_count_rtc_clk"></a></p><table class="doxtable">
<caption>RTC Clocks Source</caption>
<tr>
<th>RTC clock frequency </th><th>Clock source </th><th>Description  </th></tr>
<tr>
<td>1.024KHz </td><td>ULP1K </td><td>1.024KHz from 32KHz internal ULP oscillator  </td></tr>
<tr>
<td>32.768KHz </td><td>ULP32K </td><td>32.768KHz from 32KHz internal ULP oscillator  </td></tr>
<tr>
<td>1.024KHz </td><td>OSC1K </td><td>1.024KHz from 32KHz internal oscillator  </td></tr>
<tr>
<td>32.768KHz </td><td>OSC32K </td><td>32.768KHz from 32KHz internal oscillator  </td></tr>
<tr>
<td>1.024KHz </td><td>XOSC1K </td><td>1.024KHz from 32KHz internal oscillator  </td></tr>
<tr>
<td>32.768KHz </td><td>XOSC32K </td><td>32.768KHz from 32KHz external crystal oscillator  </td></tr>
</table>
<h1><a class="anchor" id="asfdoc_sam0_rtc_count_extra_info"></a>
Extra Information</h1>
<p >For extra information, see <a class="el" href="asfdoc_sam0_rtc_count_extra.html">Extra Information for RTC COUNT Driver</a>. This includes:</p><ul>
<li><a class="el" href="asfdoc_sam0_rtc_count_extra.html#asfdoc_sam0_rtc_count_extra_acronyms">Acronyms</a></li>
<li><a class="el" href="asfdoc_sam0_rtc_count_extra.html#asfdoc_sam0_rtc_count_extra_dependencies">Dependencies</a></li>
<li><a class="el" href="asfdoc_sam0_rtc_count_extra.html#asfdoc_sam0_rtc_count_extra_errata">Errata</a></li>
<li><a class="el" href="asfdoc_sam0_rtc_count_extra.html#asfdoc_sam0_rtc_count_extra_history">Module History</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_rtc_count_examples"></a>
Examples</h1>
<p >For a list of examples related to this driver, see <a class="el" href="asfdoc_sam0_rtc_count_exqsg.html">Examples for RTC (COUNT) Driver</a>.</p>
<h1><a class="anchor" id="asfdoc_sam0_rtc_count_api_overview"></a>
API Overview</h1>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga728e9addb0162893a3a2c9100ebd7920" name="ga728e9addb0162893a3a2c9100ebd7920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga728e9addb0162893a3a2c9100ebd7920">&#9670;&#160;</a></span>FEATURE_RTC_CONTINUOUSLY_UPDATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FEATURE_RTC_CONTINUOUSLY_UPDATED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >RTC continuously updated. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadfcb8b12ca245948cbedc1ad81c3e589" name="gadfcb8b12ca245948cbedc1ad81c3e589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfcb8b12ca245948cbedc1ad81c3e589">&#9670;&#160;</a></span>rtc_count_compare</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available compare channels. </p>
<dl class="section note"><dt>Note</dt><dd>Not all compare channels are available in all devices and modes. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadfcb8b12ca245948cbedc1ad81c3e589ac7340ee61643d3bdb0a7b4264335f080" name="ggadfcb8b12ca245948cbedc1ad81c3e589ac7340ee61643d3bdb0a7b4264335f080"></a>RTC_COUNT_COMPARE_0&#160;</td><td class="fielddoc"><p >Compare channel 0 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1c6c05a342b2711713cfac6fb3d6256c" name="ga1c6c05a342b2711713cfac6fb3d6256c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c6c05a342b2711713cfac6fb3d6256c">&#9670;&#160;</a></span>rtc_count_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#ga1c6c05a342b2711713cfac6fb3d6256c">rtc_count_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available operation modes for the RTC. </p>
<p >RTC Count operating modes, to select the counting width and associated module operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1c6c05a342b2711713cfac6fb3d6256cac1469285bb822ce84f262cd4117e8edc" name="gga1c6c05a342b2711713cfac6fb3d6256cac1469285bb822ce84f262cd4117e8edc"></a>RTC_COUNT_MODE_16BIT&#160;</td><td class="fielddoc"><p >RTC Count module operates in 16-bit mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1c6c05a342b2711713cfac6fb3d6256cad94f227d25afd2fa3c26ef9a5a33e4d8" name="gga1c6c05a342b2711713cfac6fb3d6256cad94f227d25afd2fa3c26ef9a5a33e4d8"></a>RTC_COUNT_MODE_32BIT&#160;</td><td class="fielddoc"><p >RTC Count module operates in 32-bit mode </p>
</td></tr>
</table>

</div>
</div>
<a id="gacce60ab36a74de9a173788f4aa896d15" name="gacce60ab36a74de9a173788f4aa896d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacce60ab36a74de9a173788f4aa896d15">&#9670;&#160;</a></span>rtc_count_prescaler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gacce60ab36a74de9a173788f4aa896d15">rtc_count_prescaler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RTC input clock prescaler settings. </p>
<p >The available input clock prescaler values for the RTC count module. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15aa5a98b865348eb598140b2a4247916e9" name="ggacce60ab36a74de9a173788f4aa896d15aa5a98b865348eb598140b2a4247916e9"></a>RTC_COUNT_PRESCALER_DIV_1&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15a312d3c72451ac000e95d335183ad7ec3" name="ggacce60ab36a74de9a173788f4aa896d15a312d3c72451ac000e95d335183ad7ec3"></a>RTC_COUNT_PRESCALER_DIV_2&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15ac82d71266c2f83c3d51b51fedd1ae920" name="ggacce60ab36a74de9a173788f4aa896d15ac82d71266c2f83c3d51b51fedd1ae920"></a>RTC_COUNT_PRESCALER_DIV_4&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15ac0061a5a79673614095663596f9e79f4" name="ggacce60ab36a74de9a173788f4aa896d15ac0061a5a79673614095663596f9e79f4"></a>RTC_COUNT_PRESCALER_DIV_8&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 8 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15a4e17e7e9d43d022235a7550dccffcddd" name="ggacce60ab36a74de9a173788f4aa896d15a4e17e7e9d43d022235a7550dccffcddd"></a>RTC_COUNT_PRESCALER_DIV_16&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 16 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15a3b83f1963700137784f61cd05ef49b7e" name="ggacce60ab36a74de9a173788f4aa896d15a3b83f1963700137784f61cd05ef49b7e"></a>RTC_COUNT_PRESCALER_DIV_32&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 32 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15a8b59673e870fd1205aa08b667fcc58b6" name="ggacce60ab36a74de9a173788f4aa896d15a8b59673e870fd1205aa08b667fcc58b6"></a>RTC_COUNT_PRESCALER_DIV_64&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 64 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15a2d736f3fdd6be715588ee09d7a8d1deb" name="ggacce60ab36a74de9a173788f4aa896d15a2d736f3fdd6be715588ee09d7a8d1deb"></a>RTC_COUNT_PRESCALER_DIV_128&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 128 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15a4d6f94d95f1e40f463a83148a57edcfa" name="ggacce60ab36a74de9a173788f4aa896d15a4d6f94d95f1e40f463a83148a57edcfa"></a>RTC_COUNT_PRESCALER_DIV_256&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 256 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15ab58a33623afbb13b74dcbd7e50e7760b" name="ggacce60ab36a74de9a173788f4aa896d15ab58a33623afbb13b74dcbd7e50e7760b"></a>RTC_COUNT_PRESCALER_DIV_512&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 512 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacce60ab36a74de9a173788f4aa896d15a9766bc273a9d05a8345615c5707eb4a7" name="ggacce60ab36a74de9a173788f4aa896d15a9766bc273a9d05a8345615c5707eb4a7"></a>RTC_COUNT_PRESCALER_DIV_1024&#160;</td><td class="fielddoc"><p >RTC input clock frequency is prescaled by a factor of 1024 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga51cd67b23c2a4716d09b08bf2422a222" name="ga51cd67b23c2a4716d09b08bf2422a222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51cd67b23c2a4716d09b08bf2422a222">&#9670;&#160;</a></span>rtc_count_clear_compare_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_clear_compare_match </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a>&#160;</td>
          <td class="paramname"><em>comp_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears RTC compare match flag. </p>
<p >Clears the compare flag. The compare flag is set when there is a compare match between the counter and the compare.</p>
<dl class="section note"><dt>Note</dt><dd>Compare 4 and 5 are only available in 16-bit mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_index</td><td>Index of compare to check current flag</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status indicating if flag was successfully cleared. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If flag was successfully cleared </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_FORMAT</td><td>If the module was not initialized in a mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40f97a58f45fe3fdeec606c155d4d8f3" name="ga40f97a58f45fe3fdeec606c155d4d8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40f97a58f45fe3fdeec606c155d4d8f3">&#9670;&#160;</a></span>rtc_count_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_count_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the RTC module. </p>
<p >Disables the RTC module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>RTC hardware module </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9bee70da6626ecddb461498be2c6a1b5" name="ga9bee70da6626ecddb461498be2c6a1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bee70da6626ecddb461498be2c6a1b5">&#9670;&#160;</a></span>rtc_count_disable_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_count_disable_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum rtc_count_callback&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables callback. </p>
<p >Disables the callback specified by the callback_type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Callback type to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad49e022ac982b14f592b4741fe076add" name="gad49e022ac982b14f592b4741fe076add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad49e022ac982b14f592b4741fe076add">&#9670;&#160;</a></span>rtc_count_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_count_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the RTC module. </p>
<p >Enables the RTC module once it has been configured, ready for use. Most module configuration parameters cannot be altered while the module is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>RTC hardware module </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7636683b59afd3c0d07b1191a5aff86" name="gaf7636683b59afd3c0d07b1191a5aff86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7636683b59afd3c0d07b1191a5aff86">&#9670;&#160;</a></span>rtc_count_enable_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_count_enable_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum rtc_count_callback&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables callback. </p>
<p >Enables the callback specified by the callback_type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Callback type to enable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadccb737db7dd01d7190a7f9e18b23a1b" name="gadccb737db7dd01d7190a7f9e18b23a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadccb737db7dd01d7190a7f9e18b23a1b">&#9670;&#160;</a></span>rtc_count_frequency_correction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_frequency_correction </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrate for too-slow or too-fast oscillator. </p>
<p >When used, the RTC will compensate for an inaccurate oscillator. The RTC module will add or subtract cycles from the RTC prescaler to adjust the frequency in approximately 1 PPM steps. The provided correction value should be between 0 and 127, allowing for a maximum 127 PPM correction.</p>
<p >If no correction is needed, set value to zero.</p>
<dl class="section note"><dt>Note</dt><dd>Can only be used when the RTC is operated in 1Hz.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Ranging from -127 to 127 used for the correction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the calibration procedure. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If calibration was executed correctly </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40e535c1375a99492e114722af93b675" name="ga40e535c1375a99492e114722af93b675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40e535c1375a99492e114722af93b675">&#9670;&#160;</a></span>rtc_count_get_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_get_compare </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>comp_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a>&#160;</td>
          <td class="paramname"><em>comp_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current compare value of specified compare. </p>
<p >Retrieves the current value of the specified compare.</p>
<dl class="section note"><dt>Note</dt><dd>Compare 4 and 5 are only available in 16-bit mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">comp_value</td><td>Pointer to 32-bit integer that will be populated with the current compare value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_index</td><td>Index of compare to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the reading procedure. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the value was read correctly </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_FORMAT</td><td>If the module was not initialized in a mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ad10283f223feb3c958ccabe9d0662a" name="ga3ad10283f223feb3c958ccabe9d0662a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ad10283f223feb3c958ccabe9d0662a">&#9670;&#160;</a></span>rtc_count_get_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rtc_count_get_count </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current count value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the current count value.</p>
<dl class="section return"><dt>Returns</dt><dd>The current counter value as a 32-bit unsigned integer. </dd></dl>

</div>
</div>
<a id="ga747385c5686f746a64f118705c22c894" name="ga747385c5686f746a64f118705c22c894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga747385c5686f746a64f118705c22c894">&#9670;&#160;</a></span>rtc_count_get_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_get_period </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>period_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the value of period. </p>
<p >Retrieves the value of the period for the 16-bit mode counter.</p>
<dl class="section note"><dt>Note</dt><dd>Only available in 16-bit mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">period_value</td><td>Pointer to value for return argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of getting the period value. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the period value was read correctly </td></tr>
    <tr><td class="paramname">STATUS_ERR_UNSUPPORTED_DEV</td><td>If incorrect mode was set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff43df79be7aeea0d559eafbe5fdbdc3" name="gaff43df79be7aeea0d559eafbe5fdbdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff43df79be7aeea0d559eafbe5fdbdc3">&#9670;&#160;</a></span>rtc_count_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_rtc.html">Rtc</a> *const&#160;</td>
          <td class="paramname"><em>hw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrtc__count__config.html">rtc_count_config</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the RTC module with given configurations. </p>
<p >Initializes the module, setting up all given configurations to provide the desired functionality of the RTC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to hardware instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the initialization procedure. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the initialization was run stressfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were given </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga354d81abc8c33bc39a238418611b3239" name="ga354d81abc8c33bc39a238418611b3239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga354d81abc8c33bc39a238418611b3239">&#9670;&#160;</a></span>rtc_count_is_compare_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtc_count_is_compare_match </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a>&#160;</td>
          <td class="paramname"><em>comp_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if RTC compare match has occurred. </p>
<p >Checks the compare flag to see if a match has occurred. The compare flag is set when there is a compare match between counter and the compare.</p>
<dl class="section note"><dt>Note</dt><dd>Compare 4 and 5 are only available in 16-bit mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_index</td><td>Index of compare to check current flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3679d842a95a0086fa5cbccf74aad7ee" name="ga3679d842a95a0086fa5cbccf74aad7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3679d842a95a0086fa5cbccf74aad7ee">&#9670;&#160;</a></span>rtc_count_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_register_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtc_count_callback_t&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum rtc_count_callback&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers callback for the specified callback type. </p>
<p >Associates the given callback function with the specified callback type. To enable the callback, the <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gaf7636683b59afd3c0d07b1191a5aff86">rtc_count_enable_callback</a> function must be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Pointer to the function desired for the specified callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Callback type to register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of registering callback. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>Registering was done successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If trying to register a callback not available </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga161d6cf1f6f717e8c6c650dc587cdf7a" name="ga161d6cf1f6f717e8c6c650dc587cdf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga161d6cf1f6f717e8c6c650dc587cdf7a">&#9670;&#160;</a></span>rtc_count_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtc_count_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the RTC module. Resets the RTC to hardware defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56c76be0e0fdfb5b1f9a883f396756f4" name="ga56c76be0e0fdfb5b1f9a883f396756f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c76be0e0fdfb5b1f9a883f396756f4">&#9670;&#160;</a></span>rtc_count_set_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_set_compare </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>comp_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__asfdoc__sam0__rtc__count__group.html#gadfcb8b12ca245948cbedc1ad81c3e589">rtc_count_compare</a>&#160;</td>
          <td class="paramname"><em>comp_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the compare value for the specified compare. </p>
<p >Sets the value specified by the implementer to the requested compare.</p>
<dl class="section note"><dt>Note</dt><dd>Compare 4 and 5 are only available in 16-bit mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_value</td><td>The value to be written to the compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_index</td><td>Index of the compare to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status indicating if compare was successfully set. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If compare was successfully set </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_FORMAT</td><td>If the module was not initialized in a mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3770c2c6f82daca6ca28670cd87be46f" name="ga3770c2c6f82daca6ca28670cd87be46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3770c2c6f82daca6ca28670cd87be46f">&#9670;&#160;</a></span>rtc_count_set_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_set_count </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>count_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current count value to desired value. </p>
<p >Sets the value of the counter to the specified value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count_value</td><td>The value to be set in count register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of setting the register. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If everything was executed correctly </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac0b0d3a10ee5368b5484f99e6b6fecb8" name="gac0b0d3a10ee5368b5484f99e6b6fecb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b0d3a10ee5368b5484f99e6b6fecb8">&#9670;&#160;</a></span>rtc_count_set_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_set_period </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>period_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the given value to the period. </p>
<p >Sets the given value to the period.</p>
<dl class="section note"><dt>Note</dt><dd>Only available in 16-bit mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period_value</td><td>The value to set to the period</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of setting the period value. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the period was set correctly </td></tr>
    <tr><td class="paramname">STATUS_ERR_UNSUPPORTED_DEV</td><td>If module is not operated in 16-bit mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5a8ffb958261a9b9a955c0f8fb942ea" name="gac5a8ffb958261a9b9a955c0f8fb942ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5a8ffb958261a9b9a955c0f8fb942ea">&#9670;&#160;</a></span>rtc_count_unregister_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> rtc_count_unregister_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtc__module.html">rtc_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum rtc_count_callback&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters callback for the specified callback type. </p>
<p >When called, the currently registered callback for the given callback type will be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Specifies the callback type to unregister</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of unregistering callback. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>Unregistering was done successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If trying to unregister a callback not available </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>New_RTOS_Sailboat: src/ASF/sam0/drivers/sercom/i2c/i2c_common.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">New_RTOS_Sailboat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_48df721a600249707234158a96c7fafb.html">ASF</a></li><li class="navelem"><a class="el" href="dir_7cfca43fdac2a4c30da32869189975e9.html">sam0</a></li><li class="navelem"><a class="el" href="dir_0b06f92ac913c31d435b2b546cf24f80.html">drivers</a></li><li class="navelem"><a class="el" href="dir_c056068bfe308d7dc70ed967c6f87912.html">sercom</a></li><li class="navelem"><a class="el" href="dir_f2df4f514fd41faf0bed65738ee2809c.html">i2c</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">i2c_common.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>SAM SERCOM I2C Common Driver.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="compiler_8h_source.html">compiler.h</a>&gt;</code><br />
<code>#include &lt;sercom.h&gt;</code><br />
</div>
<p><a href="i2c__common_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Driver Feature Definition</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >This driver for Atmel&reg; | SMART ARM&reg;-based microcontrollers provides an interface for the configuration and management of the device's SERCOM I<sup>2</sup>C module, for the transfer of data via an I<sup>2</sup>C bus. The following driver API modes are covered by this manual:</p>
<p >The following peripheral is used by this module:</p><ul>
<li>SERCOM (Serial Communication Interface)</li>
</ul>
<p >The following devices can use this module:</p><ul>
<li>Atmel | SMART SAM D20/D21</li>
<li>Atmel | SMART SAM R21</li>
<li>Atmel | SMART SAM D09/D10/D11</li>
<li>Atmel | SMART SAM L21/L22</li>
<li>Atmel | SMART SAM DA1</li>
<li>Atmel | SMART SAM C20/C21</li>
<li>Atmel | SMART SAM HA1</li>
<li>Atmel | SMART SAM R30</li>
<li>Atmel | SMART SAM R34</li>
<li>Atmel | SMART SAM R35</li>
</ul>
<p >The outline of this documentation is as follows:</p><ul>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_prerequisites">Prerequisites</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_overview">Module Overview</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_special_considerations">Special Considerations</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_extra">Extra Information</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_examples">Examples</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_api_overview">API Overview</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_sercom_i2c_prerequisites"></a>
Prerequisites</h1>
<p >There are no prerequisites.</p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_i2c_overview"></a>
Module Overview</h1>
<p >The outline of this section is as follows:</p><ul>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_module_features">Driver Feature Macro Definition</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_functional_desc">Functional Description</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_bus_topology">Bus Topology</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_transactions">Transactions</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_multi_master">Multi Master</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_bus_states">Bus States</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_timeout">Bus Timing</a></li>
<li><a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_sleep_modes">Operation in Sleep Modes</a></li>
</ul>
<h2><a class="anchor" id="asfdoc_sam0_sercom_i2c_module_features"></a>
Driver Feature Macro Definition</h2>
<table class="doxtable">
<tr>
<th>Driver Feature Macro </th><th>Supported devices  </th></tr>
<tr>
<td>FEATURE_I2C_FAST_MODE_PLUS_AND_HIGH_SPEED </td><td>SAM D21/R21/D10/D11/L21/L22/DA1/C20/C21/HA1/R34/R35  </td></tr>
<tr>
<td>FEATURE_I2C_10_BIT_ADDRESS </td><td>SAM D21/R21/D10/D11/L21/L22/DA1/C20/C21/HA1/R34/R35  </td></tr>
<tr>
<td>FEATURE_I2C_SCL_STRETCH_MODE </td><td>SAM D21/R21/D10/D11/L21/L22/DA1/C20/C21/HA1/R34/R35  </td></tr>
<tr>
<td>FEATURE_I2C_SCL_EXTEND_TIMEOUT </td><td>SAM D21/R21/D10/D11/L21/L22/DA1/C20/C21/HA1/R34/R35  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The specific features are only available in the driver when the selected device supports those features. </dd>
<dd>
When using the I2C high-speed mode for off-board communication, there are various high frequency interference, which can lead to distortion of the signals and communication failure. When using Xplained Pro boards in order to test I2C high-speed communication, the following recommendation should be followed:<ul>
<li>Use the SDA-line on PA08 and SCL-line on PA09 for both boards. This will provide stronger pull-ups on both SDA and SCL.</li>
<li>The SCL should not be higher than 1.5MHz.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="asfdoc_sam0_sercom_i2c_functional_desc"></a>
Functional Description</h2>
<p >The I<sup>2</sup>C provides a simple two-wire bidirectional bus consisting of a wired-AND type serial clock line (SCL) and a wired-AND type serial data line (SDA).</p>
<p >The I<sup>2</sup>C bus provides a simple, but efficient method of interconnecting multiple master and slave devices. An arbitration mechanism is provided for resolving bus ownership between masters, as only one master device may own the bus at any given time. The arbitration mechanism relies on the wired-AND connections to avoid bus drivers short-circuiting.</p>
<p >A unique address is assigned to all slave devices connected to the bus. A device can contain both master and slave logic, and can emulate multiple slave devices by responding to more than one address.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_i2c_bus_topology"></a>
Bus Topology</h2>
<p >The I<sup>2</sup>C bus topology is illustrated in <a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_bus_topology_figure">the figure below</a>. The pull-up resistors (Rs) will provide a high level on the bus lines when none of the I<sup>2</sup>C devices are driving the bus. These are optional, and can be replaced with a constant current source.</p>
<p ><a class="anchor" id="asfdoc_sam0_sercom_i2c_bus_topology_figure"></a></p><div class="image">
<object type="image/svg+xml" data="bus_topology.svg" style="pointer-events: none;"></object>
<div class="caption">
I2C Bus Topology</div></div>
<p>Width</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_i2c_transactions"></a>
Transactions</h2>
<p >The I<sup>2</sup>C standard defines three fundamental transaction formats:</p><ul>
<li>Master Write<ul>
<li>The master transmits data packets to the slave after addressing it</li>
</ul>
</li>
<li>Master Read<ul>
<li>The slave transmits data packets to the master after being addressed</li>
</ul>
</li>
<li>Combined Read/Write<ul>
<li>A combined transaction consists of several write and read transactions</li>
</ul>
</li>
</ul>
<p >A data transfer starts with the master issuing a <b>Start</b> condition on the bus, followed by the address of the slave together with a bit to indicate whether the master wants to read from or write to the slave. The addressed slave must respond to this by sending an <b>ACK</b> back to the master.</p>
<p >After this, data packets are sent from the master or slave, according to the read/write bit. Each packet must be acknowledged (ACK) or not acknowledged (NACK) by the receiver.</p>
<p >If a slave responds with a NACK, the master must assume that the slave cannot receive any more data and cancel the write operation.</p>
<p >The master completes a transaction by issuing a <b>Stop</b> condition.</p>
<p >A master can issue multiple <b>Start</b> conditions during a transaction; this is then called a <b>Repeated</b> <b>Start</b> condition.</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_i2c_address_packets"></a>
Address Packets</h3>
<p >The slave address consists of seven bits. The 8<sup>th</sup> bit in the transfer determines the data direction (read or write). An address packet always succeeds a <b>Start</b> or <b>Repeated</b> <b>Start</b> condition. The 8<sup>th</sup> bit is handled in the driver, and the user will only have to provide the 7-bit address.</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_i2c_data_packets"></a>
Data Packets</h3>
<p >Data packets are nine bits long, consisting of one 8-bit data byte, and an acknowledgement bit. Data packets follow either an address packet or another data packet on the bus.</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_i2c_trans_examples"></a>
Transaction Examples</h3>
<p >The gray bits in the following examples are sent from master to slave, and the white bits are sent from slave to master. Example of a read transaction is shown in <a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_trans_examples_i2c_read">the figure below</a>. Here, the master first issues a <b>Start</b> condition and gets ownership of the bus. An address packet with the direction flag set to read is then sent and acknowledged by the slave. Then the slave sends one data packet which is acknowledged by the master. The slave sends another packet, which is not acknowledged by the master and indicates that the master will terminate the transaction. In the end, the transaction is terminated by the master issuing a <b>Stop</b> condition.</p>
<p ><a class="anchor" id="asfdoc_sam0_sercom_i2c_trans_examples_i2c_read"></a></p><div class="image">
<object type="image/svg+xml" data="i2c_read.svg" style="pointer-events: none;"></object>
<div class="caption">
I2C Packet Read</div></div>
<p>Width</p>
<p >Example of a write transaction is shown in <a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_trans_examples_i2c_write">the figure below</a>. Here, the master first issues a <b>Start</b> condition and gets ownership of the bus. An address packet with the dir flag set to write is then sent and acknowledged by the slave. Then the master sends two data packets, each acknowledged by the slave. In the end, the transaction is terminated by the master issuing a <b>Stop</b> condition.</p>
<p ><a class="anchor" id="asfdoc_sam0_sercom_i2c_trans_examples_i2c_write"></a></p><div class="image">
<object type="image/svg+xml" data="i2c_write.svg" style="pointer-events: none;"></object>
<div class="caption">
I2C Packet Write</div></div>
<p>Width</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_i2c_packet_timeout"></a>
Packet Timeout</h3>
<p >When a master sends an I<sup>2</sup>C packet, there is no way of being sure that a slave will acknowledge the packet. To avoid stalling the device forever while waiting for an acknowledge, a user selectable timeout is provided in the <a class="el" href="structi2c__master__config.html">i2c_master_config</a> struct which lets the driver exit a read or write operation after the specified time. The function will then return the STATUS_ERR_TIMEOUT flag.</p>
<p >This is also the case for the slave when using the functions postfixed <code>_wait</code>.</p>
<p >The time before the timeout occurs, will be the same as for <a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_unknown_bus_timeout">unknown bus state</a> timeout.</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_i2c_repeated_start"></a>
Repeated Start</h3>
<p >To issue a <b>Repeated</b> <b>Start</b>, the functions postfixed <code>_no_stop</code> must be used. These functions will not send a <b>Stop</b> condition when the transfer is done, thus the next transfer will start with a <b>Repeated</b> <b>Start</b>. To end the transaction, the functions without the <code>_no_stop</code> postfix must be used for the last read/write.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_i2c_multi_master"></a>
Multi Master</h2>
<p >In a multi master environment, arbitration of the bus is important, as only one master can own the bus at any point.</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_i2c_arbitration"></a>
Arbitration</h3>
<dl class="section user"><dt>Clock stretching</dt><dd>The serial clock line is always driven by a master device. However, all devices connected to the bus are allowed stretch the low period of the clock to slow down the overall clock frequency or to insert wait states while processing data. Both master and slave can randomly stretch the clock, which will force the other device into a wait-state until the clock line goes high again.</dd></dl>
<dl class="section user"><dt>Arbitration on the data line</dt><dd>If two masters start transmitting at the same time, they will both transmit until one master detects that the other master is pulling the data line low. When this is detected, the master not pulling the line low, will stop the transmission and wait until the bus is idle. As it is the master trying to contact the slave with the lowest address that will get the bus ownership, this will create an arbitration scheme always prioritizing the slaves with the lowest address in case of a bus collision.</dd></dl>
<h3><a class="anchor" id="asfdoc_sam0_sercom_i2c_clock_sync"></a>
Clock Synchronization</h3>
<p >In situations where more than one master is trying to control the bus clock line at the same time, a clock synchronization algorithm based on the same principles used for clock stretching is necessary.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_i2c_bus_states"></a>
Bus States</h2>
<p >As the I<sup>2</sup>C bus is limited to one transaction at the time, a master that wants to perform a bus transaction must wait until the bus is free. Because of this, it is necessary for all masters in a multi-master system to know the current status of the bus to be able to avoid conflicts and to ensure data integrity. </p><ul>
<li><b>IDLE</b> No activity on the bus (between a <b>Stop</b> and a new <b>Start</b> condition) </li>
<li><b>OWNER</b> If the master initiates a transaction successfully </li>
<li><b>BUSY</b> If another master is driving the bus </li>
<li><b>UNKNOWN</b> If the master has recently been enabled or connected to the bus. Is forced to <b>IDLE</b> after given <a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_unknown_bus_timeout">timeout</a> when the master module is enabled</li>
</ul>
<p>The bus state diagram can be seen in <a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_bus_states_figure">the figure below</a>. </p><ul>
<li>S: Start condition </li>
<li>P: Stop condition </li>
<li>Sr: Repeated start condition <a class="anchor" id="asfdoc_sam0_sercom_i2c_bus_states_figure"></a><div class="image">
<object type="image/svg+xml" data="bus_state_diagram.svg" style="pointer-events: none;"></object>
<div class="caption">
I2C Bus State Diagram</div></div>
Width</li>
</ul>
<h2><a class="anchor" id="asfdoc_sam0_sercom_i2c_timeout"></a>
Bus Timing</h2>
<p >Inactive bus timeout for the master and SDA hold time is configurable in the drivers.</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_i2c_unknown_bus_timeout"></a>
Unknown Bus State Timeout</h3>
<p >When a master is enabled or connected to the bus, the bus state will be unknown until either a given timeout or a stop command has occurred. The timeout is configurable in the <a class="el" href="structi2c__master__config.html">i2c_master_config</a> struct. The timeout time will depend on toolchain and optimization level used, as the timeout is a loop incrementing a value until it reaches the specified timeout value.</p>
<h3><a class="anchor" id="sda_hold"></a>
SDA Hold Timeout</h3>
<p >When using the I<sup>2</sup>C in slave mode, it will be important to set a SDA hold time which assures that the master will be able to pick up the bit sent from the slave. The SDA hold time makes sure that this is the case by holding the data line low for a given period after the negative edge on the clock.</p>
<p >The SDA hold time is also available for the master driver, but is not a necessity.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_i2c_sleep_modes"></a>
Operation in Sleep Modes</h2>
<p >The I<sup>2</sup>C module can operate in all sleep modes by setting the run_in_standby Boolean in the <a class="el" href="structi2c__master__config.html">i2c_master_config</a> or i2c_slave_config struct. The operation in slave and master mode is shown in <a class="el" href="i2c__common_8h.html#asfdoc_sam0_sercom_i2c_sleep_modes_table">the table below</a>.</p>
<p ><a class="anchor" id="asfdoc_sam0_sercom_i2c_sleep_modes_table"></a></p><table class="doxtable">
<caption>I2C Standby Operations</caption>
<tr>
<th>Run in standby </th><th>Slave </th><th>Master  </th></tr>
<tr>
<td>false </td><td>Disabled, all reception is dropped </td><td>Generic Clock (GCLK) disabled when master is idle  </td></tr>
<tr>
<td>true </td><td>Wake on address match when enabled </td><td>GCLK enabled while in sleep modes  </td></tr>
</table>
<h1><a class="anchor" id="asfdoc_sam0_sercom_i2c_special_considerations"></a>
Special Considerations</h1>
<p >There are no special considerations for this driver for the APIs listed in this document. </p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_i2c_extra"></a>
Extra Information</h1>
<p >For extra information, see <a class="el" href="asfdoc_sam0_sercom_i2c_extra_info_page.html">Extra Information for SERCOM I2C Driver</a>. This includes:</p><ul>
<li><a class="el" href="asfdoc_sam0_sercom_i2c_extra_info_page.html#asfdoc_sam0_sercom_i2c_acronyms">Acronyms</a></li>
<li><a class="el" href="asfdoc_sam0_sercom_i2c_extra_info_page.html#asfdoc_sam0_sercom_i2c_extra_dependencies">Dependencies</a></li>
<li><a class="el" href="asfdoc_sam0_sercom_i2c_extra_info_page.html#asfdoc_sam0_sercom_i2c_extra_errata">Errata</a></li>
<li><a class="el" href="asfdoc_sam0_sercom_i2c_extra_info_page.html#asfdoc_sam0_sercom_i2c_extra_history">Module History</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_sercom_i2c_examples"></a>
Examples</h1>
<p >For a list of examples related to this driver, see <a class="el" href="asfdoc_sam0_sercom_i2c_exqsg.html">Examples for SERCOM I2C Driver</a>.</p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_i2c_api_overview"></a>
API Overview</h1>
<p >Define SERCOM I<sup>2</sup>C driver features set according to different device family. </p>
</div></td></tr>
<tr class="memitem:ad7ea327439ceaf6931b91865d12449fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c__common_8h.html#ad7ea327439ceaf6931b91865d12449fc">i2c_transfer_direction</a> { <a class="el" href="i2c__common_8h.html#ad7ea327439ceaf6931b91865d12449fcaea641e04129636c150a843d7375b9269">I2C_TRANSFER_WRITE</a> = 0
, <a class="el" href="i2c__common_8h.html#ad7ea327439ceaf6931b91865d12449fca2b5fe52816ac7ab8ea272beb274cfd0c">I2C_TRANSFER_READ</a> = 1
 }</td></tr>
<tr class="memdesc:ad7ea327439ceaf6931b91865d12449fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer direction.  <a href="i2c__common_8h.html#ad7ea327439ceaf6931b91865d12449fc">More...</a><br /></td></tr>
<tr class="separator:ad7ea327439ceaf6931b91865d12449fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >SAM SERCOM I2C Common Driver. </p>
<p >Copyright (c) 2012-2020 Microchip Technology Inc. and its subsidiaries.</p>
<p >\asf_license_start </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad7ea327439ceaf6931b91865d12449fc" name="ad7ea327439ceaf6931b91865d12449fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ea327439ceaf6931b91865d12449fc">&#9670;&#160;</a></span>i2c_transfer_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="i2c__common_8h.html#ad7ea327439ceaf6931b91865d12449fc">i2c_transfer_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer direction. </p>
<p >For master: transfer direction or setting direction bit in address. For slave: direction of request from master. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad7ea327439ceaf6931b91865d12449fcaea641e04129636c150a843d7375b9269" name="ad7ea327439ceaf6931b91865d12449fcaea641e04129636c150a843d7375b9269"></a>I2C_TRANSFER_WRITE&#160;</td><td class="fielddoc"><p >Master write operation is in progress </p>
</td></tr>
<tr><td class="fieldname"><a id="ad7ea327439ceaf6931b91865d12449fca2b5fe52816ac7ab8ea272beb274cfd0c" name="ad7ea327439ceaf6931b91865d12449fca2b5fe52816ac7ab8ea272beb274cfd0c"></a>I2C_TRANSFER_READ&#160;</td><td class="fielddoc"><p >Master read operation is in progress </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
